<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fractal Chaos Game</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --surface2: #21262d;
    --border: #30363d;
    --text: #e6edf3;
    --text-dim: #8b949e;
    --accent: #58a6ff;
    --accent-hover: #79c0ff;
    --green: #3fb950;
    --red: #f85149;
    --orange: #d29922;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
  }

  /* Sidebar */
  .sidebar {
    width: 320px;
    min-width: 320px;
    background: var(--surface);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
  }

  .sidebar-header {
    padding: 20px 20px 12px;
    border-bottom: 1px solid var(--border);
  }

  .sidebar-header h1 {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 4px;
  }

  .sidebar-header p {
    font-size: 12px;
    color: var(--text-dim);
  }

  .control-group {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }

  .control-group label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .control-group .value-display {
    font-size: 13px;
    color: var(--accent);
    font-weight: 600;
    float: right;
    text-transform: none;
    letter-spacing: 0;
  }

  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--surface2);
    outline: none;
    margin: 8px 0;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg);
  }

  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg);
  }

  /* Preset buttons */
  .preset-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .preset-btn {
    padding: 5px 12px;
    font-size: 13px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }

  .preset-btn:hover { border-color: var(--accent); color: var(--accent); }
  .preset-btn.active { background: var(--accent); color: var(--bg); border-color: var(--accent); font-weight: 600; }

  /* Custom F input */
  .custom-f-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
  }

  .custom-f-row span {
    font-size: 12px;
    color: var(--text-dim);
    white-space: nowrap;
  }

  input[type="number"] {
    width: 100%;
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    font-family: 'SF Mono', 'Fira Code', monospace;
    outline: none;
  }

  input[type="number"]:focus { border-color: var(--accent); }

  /* Color controls */
  .color-mode-row {
    display: flex;
    gap: 6px;
    margin-bottom: 10px;
  }

  input[type="color"] {
    -webkit-appearance: none;
    width: 40px;
    height: 32px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    cursor: pointer;
    padding: 2px;
  }

  input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
  input[type="color"]::-webkit-color-swatch { border-radius: 3px; border: none; }

  .color-picker-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .color-picker-row span {
    font-size: 13px;
    color: var(--text-dim);
  }

  /* Action buttons */
  .actions {
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    border-bottom: 1px solid var(--border);
  }

  .btn {
    padding: 10px 16px;
    font-size: 14px;
    font-weight: 600;
    border-radius: 8px;
    border: 1px solid var(--border);
    cursor: pointer;
    font-family: inherit;
    transition: all 0.15s;
    text-align: center;
  }

  .btn-run {
    background: var(--green);
    color: var(--bg);
    border-color: var(--green);
  }
  .btn-run:hover { filter: brightness(1.1); }
  .btn-run:disabled { opacity: 0.5; cursor: not-allowed; }

  .btn-stop {
    background: var(--red);
    color: #fff;
    border-color: var(--red);
  }
  .btn-stop:hover { filter: brightness(1.1); }

  .btn-row {
    display: flex;
    gap: 8px;
  }

  .btn-secondary {
    background: var(--surface2);
    color: var(--text);
    flex: 1;
  }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }

  /* Progress */
  .progress-container {
    padding: 0 20px 16px;
  }

  .progress-bar-bg {
    width: 100%;
    height: 6px;
    background: var(--surface2);
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 6px;
  }

  .progress-bar-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 3px;
    width: 0%;
    transition: width 0.1s;
  }

  .progress-text {
    font-size: 11px;
    color: var(--text-dim);
    font-family: 'SF Mono', 'Fira Code', monospace;
    display: flex;
    justify-content: space-between;
  }

  /* Presets section */
  .presets-section {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }

  .presets-section label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .scene-preset {
    display: block;
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 4px;
    font-size: 13px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    text-align: left;
    font-family: inherit;
    transition: all 0.15s;
  }

  .scene-preset:hover { border-color: var(--accent); color: var(--accent); }
  .scene-preset .desc { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

  /* Canvas area */
  .canvas-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background: #000;
    overflow: hidden;
  }

  canvas {
    display: block;
  }

  /* Info overlay */
  .info-overlay {
    position: absolute;
    top: 12px;
    right: 16px;
    font-size: 12px;
    color: var(--text-dim);
    font-family: 'SF Mono', 'Fira Code', monospace;
    text-align: right;
    pointer-events: none;
    line-height: 1.6;
  }

  /* Prompt output */
  .prompt-section {
    padding: 16px 20px;
    flex-shrink: 0;
  }

  .prompt-section label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
    margin-bottom: 6px;
  }

  .prompt-output {
    font-size: 12px;
    color: var(--text);
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 12px;
    min-height: 48px;
    max-height: 100px;
    overflow-y: auto;
    line-height: 1.5;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .copy-btn {
    margin-top: 6px;
    padding: 5px 14px;
    font-size: 12px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    font-family: inherit;
    transition: all 0.15s;
  }

  .copy-btn:hover { border-color: var(--accent); color: var(--accent); }

  /* Dot size control */
  .dot-size-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* Zoom toolbar */
  .zoom-toolbar {
    position: absolute;
    top: 12px;
    left: 12px;
    display: flex;
    gap: 4px;
    align-items: center;
    z-index: 10;
    pointer-events: auto;
  }

  .zoom-btn {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.15);
    background: rgba(22,27,34,0.85);
    color: var(--text);
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    font-family: inherit;
    backdrop-filter: blur(8px);
  }

  .zoom-btn:hover { border-color: var(--accent); color: var(--accent); }

  .zoom-level {
    padding: 4px 10px;
    font-size: 11px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    color: var(--text-dim);
    background: rgba(22,27,34,0.85);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.15);
    backdrop-filter: blur(8px);
    pointer-events: none;
    min-width: 48px;
    text-align: center;
  }

  /* Selection rectangle */
  .selection-rect {
    position: absolute;
    border: 2px dashed var(--accent);
    background: rgba(88,166,255,0.08);
    pointer-events: none;
    z-index: 5;
    display: none;
  }

  /* Canvas cursor states */
  .canvas-area.pan-mode { cursor: grab; }
  .canvas-area.panning { cursor: grabbing; }
  .canvas-area.select-mode { cursor: crosshair; }
</style>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <h1>Fractal Chaos Game</h1>
    <p>Random point iteration reveals hidden fractal geometry</p>
  </div>

  <!-- Scene Presets -->
  <div class="presets-section">
    <label>Presets</label>
    <button class="scene-preset" onclick="applyPreset('sierpinski')">
      Sierpinski Triangle <div class="desc">3 points, F = 0.5000</div>
    </button>
    <button class="scene-preset" onclick="applyPreset('pentagon')">
      Pentagonal Gasket <div class="desc">5 points, F = 0.6180</div>
    </button>
    <button class="scene-preset" onclick="applyPreset('hexagon')">
      Hexagonal Gasket <div class="desc">6 points, F = 0.6667</div>
    </button>
    <button class="scene-preset" onclick="applyPreset('octagon')">
      Octagonal Gasket <div class="desc">8 points, F = 0.7071</div>
    </button>
    <button class="scene-preset" onclick="applyPreset('dodecagon')">
      Dodecagonal Gasket <div class="desc">12 points, F = 0.7887</div>
    </button>
  </div>

  <!-- Number of vertices -->
  <div class="control-group">
    <label>Vertices (N) <span class="value-display" id="verticesValue">3</span></label>
    <input type="range" id="verticesSlider" min="2" max="12" value="3" step="1">
  </div>

  <!-- Total points -->
  <div class="control-group">
    <label>Total Points <span class="value-display" id="pointsValue">500,000</span></label>
    <input type="range" id="pointsSlider" min="0" max="800" value="570" step="1">
    <div style="display:flex; justify-content:space-between; font-size:10px; color:var(--text-dim);">
      <span>1</span><span>100M</span>
    </div>
  </div>

  <!-- Fractal Dimension -->
  <div class="control-group">
    <label>Fractal Ratio (F) <span class="value-display" id="fractalValue">0.5000</span></label>
    <div class="preset-row">
      <button class="preset-btn" onclick="setOptimalF()" id="optimalBtn" title="Calculate optimal F for current vertex count" style="background:var(--accent);color:var(--bg);border-color:var(--accent);font-weight:600;">Optimal</button>
      <button class="preset-btn" onclick="setF(1/2)">1/2</button>
      <button class="preset-btn" onclick="setF(1/3)">1/3</button>
      <button class="preset-btn" onclick="setF(2/3)">2/3</button>
      <button class="preset-btn" onclick="setF(3/8)">3/8</button>
    </div>
    <div class="custom-f-row">
      <span>Custom:</span>
      <input type="number" id="customF" min="0.001" max="0.999" step="0.001" value="0.5000" placeholder="0.001 - 0.999">
    </div>
  </div>

  <!-- Dot Size -->
  <div class="control-group">
    <label>Dot Size <span class="value-display" id="dotSizeValue">1 px</span></label>
    <input type="range" id="dotSizeSlider" min="0.5" max="4" value="1" step="0.5">
  </div>

  <!-- Color Mode -->
  <div class="control-group">
    <label>Color</label>
    <div class="color-mode-row">
      <button class="preset-btn active" id="singleColorBtn" onclick="setColorMode('single')">Single Color</button>
      <button class="preset-btn" id="randomColorBtn" onclick="setColorMode('random')">Random</button>
      <button class="preset-btn" id="vertexColorBtn" onclick="setColorMode('vertex')">By Vertex</button>
    </div>
    <div class="color-picker-row" id="colorPickerRow">
      <input type="color" id="dotColor" value="#58a6ff">
      <span id="colorHex">#58a6ff</span>
    </div>
    <div id="opacityRow" style="margin-top: 8px;">
      <label style="margin-bottom: 4px;">Opacity <span class="value-display" id="opacityValue">80%</span></label>
      <input type="range" id="opacitySlider" min="1" max="100" value="80" step="1">
    </div>
  </div>

  <!-- Actions -->
  <div class="actions">
    <button class="btn btn-run" id="runBtn" onclick="startRun()">Run</button>
    <div class="btn-row">
      <button class="btn btn-secondary" onclick="clearCanvas()">Clear All</button>
      <button class="btn btn-secondary" onclick="saveAs()">Save As</button>
    </div>
  </div>

  <!-- Progress -->
  <div class="progress-container" id="progressContainer" style="display:none;">
    <div class="progress-bar-bg">
      <div class="progress-bar-fill" id="progressFill"></div>
    </div>
    <div class="progress-text">
      <span id="progressCount">0 / 0</span>
      <span id="progressRate"></span>
    </div>
  </div>

  <!-- Prompt Output -->
  <div class="prompt-section">
    <label>Configuration</label>
    <div class="prompt-output" id="promptOutput"></div>
    <button class="copy-btn" onclick="copyPrompt()">Copy</button>
  </div>
</div>

<div class="canvas-area pan-mode" id="canvasArea">
  <canvas id="fractalCanvas"></canvas>
  <div class="zoom-toolbar">
    <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
    <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">&minus;</button>
    <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom" style="font-size:12px;">&#8634;</button>
    <div class="zoom-level" id="zoomLevel">1.0x</div>
  </div>
  <div class="selection-rect" id="selectionRect"></div>
  <div class="info-overlay" id="infoOverlay"></div>
</div>

<script>
  // ============================================================
  //  STATE
  // ============================================================
  const MAX_BUFFER_POINTS = 10_000_000; // 10M point cap (~90MB)

  const state = {
    vertices: 3,
    totalPoints: 500000,
    fractalF: 0.5,
    colorMode: 'single',
    singleColor: '#58a6ff',
    opacity: 0.8,
    dotSize: 1,
    running: false,
    pointsDrawn: 0,
    animFrameId: null,
    startTime: 0,
    // View transform
    viewCenterX: 0.5,
    viewCenterY: 0.5,
    viewZoom: 1.0,
    // Point buffer (world coords)
    pointsX: null,
    pointsY: null,
    pointsVI: null,
    pointsStored: 0,
    pointsCapacity: 0,
    // Run-time color snapshot (for re-render)
    runColorMode: 'single',
    runSingleColor: '#58a6ff',
    runOpacity: 0.8,
    runDotSize: 1,
  };

  // ============================================================
  //  OPTIMAL F
  // ============================================================
  function calcOptimalF(n) {
    if (n % 4 === 0) return 1 / (1 + Math.tan(Math.PI / n));
    if (n % 2 === 0) return 1 / (1 + Math.sin(Math.PI / n));
    return 1 / (1 + 2 * Math.sin(Math.PI / (2 * n)));
  }

  function setOptimalF() { setF(calcOptimalF(state.vertices)); }

  // ============================================================
  //  ELEMENTS
  // ============================================================
  const canvas = document.getElementById('fractalCanvas');
  const ctx = canvas.getContext('2d');
  const canvasArea = document.getElementById('canvasArea');
  const selectionRect = document.getElementById('selectionRect');
  const zoomLevelEl = document.getElementById('zoomLevel');

  const verticesSlider = document.getElementById('verticesSlider');
  const pointsSlider = document.getElementById('pointsSlider');
  const dotSizeSlider = document.getElementById('dotSizeSlider');
  const opacitySlider = document.getElementById('opacitySlider');
  const customFInput = document.getElementById('customF');
  const dotColorInput = document.getElementById('dotColor');
  const runBtn = document.getElementById('runBtn');
  const progressContainer = document.getElementById('progressContainer');
  const progressFill = document.getElementById('progressFill');
  const progressCount = document.getElementById('progressCount');
  const progressRate = document.getElementById('progressRate');
  const infoOverlay = document.getElementById('infoOverlay');

  // ============================================================
  //  UTILITIES
  // ============================================================
  function sliderToPoints(val) {
    return Math.round(Math.pow(10, (val / 800) * 8));
  }

  function formatNumber(n) {
    if (n >= 1e6) return (n / 1e6).toFixed(1).replace(/\.0$/, '') + 'M';
    if (n >= 1e3) return (n / 1e3).toFixed(1).replace(/\.0$/, '') + 'K';
    return n.toLocaleString();
  }

  function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) { r = g = b = l; }
    else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1; if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }

  const VERTEX_HUES = [0, 30, 60, 120, 180, 210, 240, 270, 300, 330, 15, 45];

  function vertexColor(idx, opacity) {
    return `hsla(${VERTEX_HUES[idx % 12]}, 85%, 60%, ${opacity})`;
  }

  function hexToRgb(hex) {
    return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
  }

  // ============================================================
  //  CANVAS SIZING
  // ============================================================
  let canvasSize = 600; // CSS pixels

  function resizeCanvas() {
    const rect = canvasArea.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvasSize = Math.min(rect.width, rect.height) - 40;
    canvas.width = canvasSize * dpr;
    canvas.height = canvasSize * dpr;
    canvas.style.width = canvasSize + 'px';
    canvas.style.height = canvasSize + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return canvasSize;
  }

  // ============================================================
  //  COORDINATE TRANSFORMS (world 0-1 <-> screen pixels)
  // ============================================================
  function worldToScreen(wx, wy) {
    const z = state.viewZoom;
    const sx = (wx - state.viewCenterX) * z * canvasSize + canvasSize / 2;
    const sy = (wy - state.viewCenterY) * z * canvasSize + canvasSize / 2;
    return [sx, sy];
  }

  function screenToWorld(sx, sy) {
    const z = state.viewZoom;
    const wx = (sx - canvasSize / 2) / (z * canvasSize) + state.viewCenterX;
    const wy = (sy - canvasSize / 2) / (z * canvasSize) + state.viewCenterY;
    return [wx, wy];
  }

  // ============================================================
  //  VERTICES (world coords, centered at 0.5, 0.5)
  // ============================================================
  function getVertices(n) {
    const cx = 0.5, cy = 0.5, R = 0.425;
    const verts = [];
    for (let i = 0; i < n; i++) {
      const angle = -Math.PI / 2 + (2 * Math.PI * i) / n;
      verts.push({ x: cx + R * Math.cos(angle), y: cy + R * Math.sin(angle) });
    }
    return verts;
  }

  function drawVertices(verts) {
    ctx.save();
    verts.forEach((v, i) => {
      const [sx, sy] = worldToScreen(v.x, v.y);
      if (sx < -20 || sx > canvasSize + 20 || sy < -20 || sy > canvasSize + 20) return;

      ctx.beginPath();
      ctx.arc(sx, sy, 5, 0, Math.PI * 2);
      ctx.fillStyle = state.runColorMode === 'vertex' ? vertexColor(i, 1) : 'rgba(255,255,255,0.7)';
      ctx.fill();

      const dx = v.x - 0.5, dy = v.y - 0.5;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const lx = sx + (dx / dist) * 16;
      const ly = sy + (dy / dist) * 16;
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = '11px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`P${i + 1}`, lx, ly);
    });
    ctx.restore();
  }

  // ============================================================
  //  POINT BUFFER
  // ============================================================
  function ensurePointBuffer(needed) {
    const cap = Math.min(needed, MAX_BUFFER_POINTS);
    if (cap <= state.pointsCapacity) return;
    const newCap = Math.min(Math.max(cap, (state.pointsCapacity || 1024) * 2), MAX_BUFFER_POINTS);
    const newX = new Float32Array(newCap);
    const newY = new Float32Array(newCap);
    const newVI = new Uint8Array(newCap);
    if (state.pointsX) {
      newX.set(state.pointsX.subarray(0, state.pointsStored));
      newY.set(state.pointsY.subarray(0, state.pointsStored));
      newVI.set(state.pointsVI.subarray(0, state.pointsStored));
    }
    state.pointsX = newX;
    state.pointsY = newY;
    state.pointsVI = newVI;
    state.pointsCapacity = newCap;
  }

  function clearPointBuffer() {
    state.pointsX = null;
    state.pointsY = null;
    state.pointsVI = null;
    state.pointsStored = 0;
    state.pointsCapacity = 0;
  }

  function storePoint(wx, wy, vi) {
    if (state.pointsStored >= MAX_BUFFER_POINTS) return;
    if (state.pointsStored >= state.pointsCapacity) ensurePointBuffer(state.pointsStored + 1);
    state.pointsX[state.pointsStored] = wx;
    state.pointsY[state.pointsStored] = wy;
    state.pointsVI[state.pointsStored] = vi;
    state.pointsStored++;
  }

  // ============================================================
  //  RENDER FROM BUFFER (re-render on zoom/pan)
  // ============================================================
  function renderFromBuffer() {
    const size = canvasSize;
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.width, h = canvas.height;

    const imageData = ctx.getImageData(0, 0, w, h);
    const pixels = imageData.data;
    // Clear to black
    for (let i = 0; i < pixels.length; i += 4) {
      pixels[i] = pixels[i+1] = pixels[i+2] = 0;
      pixels[i+3] = 255;
    }

    const count = state.pointsStored;
    if (count === 0) { ctx.putImageData(imageData, 0, 0); return; }

    const px = state.pointsX, py = state.pointsY, pvi = state.pointsVI;
    const z = state.viewZoom;
    const vcx = state.viewCenterX, vcy = state.viewCenterY;
    const halfSize = size / 2;
    const scale = z * size * dpr;
    const offX = halfSize * dpr - vcx * scale;
    const offY = halfSize * dpr - vcy * scale;

    const colorMode = state.runColorMode;
    const opacity = state.runOpacity;
    const dotSize = state.runDotSize;

    // Precompute colors
    let sr = 0, sg = 0, sb = 0;
    if (colorMode === 'single' || colorMode === 'random') {
      const rgb = hexToRgb(state.runSingleColor);
      sr = rgb[0]; sg = rgb[1]; sb = rgb[2];
    }

    const vertRGBs = [];
    const n = state.vertices;
    for (let i = 0; i < n; i++) {
      const rgb = hslToRgb(VERTEX_HUES[i % 12] / 360, 0.85, 0.6);
      vertRGBs.push(rgb);
    }

    if (dotSize <= 1) {
      // Single-pixel fast path
      for (let i = 0; i < count; i++) {
        const screenX = Math.round(px[i] * scale + offX);
        const screenY = Math.round(py[i] * scale + offY);
        if (screenX < 0 || screenX >= w || screenY < 0 || screenY >= h) continue;

        const idx = (screenY * w + screenX) * 4;
        let cr, cg, cb;
        if (colorMode === 'vertex') {
          const vc = vertRGBs[pvi[i]];
          cr = vc[0]; cg = vc[1]; cb = vc[2];
        } else {
          cr = sr; cg = sg; cb = sb;
        }
        pixels[idx]     = Math.min(255, Math.round(cr * opacity + pixels[idx] * (1 - opacity)));
        pixels[idx + 1] = Math.min(255, Math.round(cg * opacity + pixels[idx + 1] * (1 - opacity)));
        pixels[idx + 2] = Math.min(255, Math.round(cb * opacity + pixels[idx + 2] * (1 - opacity)));
      }
    } else {
      // Multi-pixel path
      const halfDot = Math.ceil(dotSize * dpr / 2);
      for (let i = 0; i < count; i++) {
        const cx = Math.round(px[i] * scale + offX);
        const cy = Math.round(py[i] * scale + offY);
        if (cx < -halfDot || cx >= w + halfDot || cy < -halfDot || cy >= h + halfDot) continue;

        let cr, cg, cb;
        if (colorMode === 'vertex') {
          const vc = vertRGBs[pvi[i]];
          cr = vc[0]; cg = vc[1]; cb = vc[2];
        } else {
          cr = sr; cg = sg; cb = sb;
        }

        const x0 = Math.max(0, cx - halfDot), x1 = Math.min(w - 1, cx + halfDot);
        const y0 = Math.max(0, cy - halfDot), y1 = Math.min(h - 1, cy + halfDot);
        for (let py2 = y0; py2 <= y1; py2++) {
          for (let px2 = x0; px2 <= x1; px2++) {
            const idx = (py2 * w + px2) * 4;
            pixels[idx]     = Math.min(255, Math.round(cr * opacity + pixels[idx] * (1 - opacity)));
            pixels[idx + 1] = Math.min(255, Math.round(cg * opacity + pixels[idx + 1] * (1 - opacity)));
            pixels[idx + 2] = Math.min(255, Math.round(cb * opacity + pixels[idx + 2] * (1 - opacity)));
          }
        }
      }
    }

    ctx.putImageData(imageData, 0, 0);

    // Draw vertex markers on top
    const verts = getVertices(state.vertices);
    drawVertices(verts);
    updateZoomDisplay();
  }

  // ============================================================
  //  MAIN FRACTAL RUN
  // ============================================================
  function startRun() {
    if (state.running) { stopRun(); return; }

    resizeCanvas();

    // Reset view and buffer
    state.viewCenterX = 0.5;
    state.viewCenterY = 0.5;
    state.viewZoom = 1.0;
    clearPointBuffer();
    ensurePointBuffer(Math.min(state.totalPoints, MAX_BUFFER_POINTS));

    // Snapshot color settings for re-render
    state.runColorMode = state.colorMode;
    state.runSingleColor = state.singleColor;
    state.runOpacity = state.opacity;
    state.runDotSize = state.dotSize;

    const verts = getVertices(state.vertices);
    const n = state.vertices;
    const total = state.totalPoints;
    const F = state.fractalF;
    const dotSize = state.dotSize;
    const opacity = state.opacity;
    const colorMode = state.colorMode;
    const singleColor = state.singleColor;

    state.running = true;
    state.pointsDrawn = 0;
    state.startTime = performance.now();
    runBtn.textContent = 'Stop';
    runBtn.className = 'btn btn-stop';
    progressContainer.style.display = 'block';

    // Starting point
    const sv = verts[Math.floor(Math.random() * n)];
    let wx = sv.x, wy = sv.y;

    const batchSize = Math.min(Math.max(1000, Math.floor(total / 200)), 500000);
    const dpr = window.devicePixelRatio || 1;
    const size = canvasSize;

    // Use ImageData for fast initial render
    const useImageData = total > 100000 && dotSize <= 1 && colorMode !== 'random';
    let imageData, pixels;

    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, size, size);

    if (useImageData) {
      imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      pixels = imageData.data;
    }

    // Precompute colors
    let sr = 0, sg = 0, sb = 0;
    if (colorMode === 'single') {
      const rgb = hexToRgb(singleColor);
      sr = rgb[0]; sg = rgb[1]; sb = rgb[2];
    }
    const vertRGBs = [];
    for (let i = 0; i < n; i++) {
      vertRGBs.push(hslToRgb(VERTEX_HUES[i % 12] / 360, 0.85, 0.6));
    }

    // View transform constants for initial render (zoom=1, center=0.5,0.5)
    const scale = size * dpr;
    const offX = size * dpr / 2 - 0.5 * scale;
    const offY = size * dpr / 2 - 0.5 * scale;
    const cw = canvas.width, ch = canvas.height;

    function renderBatch() {
      if (!state.running) return;
      const batchEnd = Math.min(state.pointsDrawn + batchSize, total);

      if (useImageData) {
        for (let i = state.pointsDrawn; i < batchEnd; i++) {
          const vi = Math.floor(Math.random() * n);
          const v = verts[vi];
          wx = wx + (v.x - wx) * F;
          wy = wy + (v.y - wy) * F;

          storePoint(wx, wy, vi);

          const screenX = Math.round(wx * scale + offX);
          const screenY = Math.round(wy * scale + offY);
          if (screenX < 0 || screenX >= cw || screenY < 0 || screenY >= ch) continue;

          const idx = (screenY * cw + screenX) * 4;
          let cr, cg, cb;
          if (colorMode === 'vertex') {
            cr = vertRGBs[vi][0]; cg = vertRGBs[vi][1]; cb = vertRGBs[vi][2];
          } else {
            cr = sr; cg = sg; cb = sb;
          }
          pixels[idx]     = Math.min(255, Math.round(cr * opacity + pixels[idx] * (1 - opacity)));
          pixels[idx + 1] = Math.min(255, Math.round(cg * opacity + pixels[idx + 1] * (1 - opacity)));
          pixels[idx + 2] = Math.min(255, Math.round(cb * opacity + pixels[idx + 2] * (1 - opacity)));
        }
      } else {
        for (let i = state.pointsDrawn; i < batchEnd; i++) {
          const vi = Math.floor(Math.random() * n);
          const v = verts[vi];
          wx = wx + (v.x - wx) * F;
          wy = wy + (v.y - wy) * F;

          storePoint(wx, wy, vi);

          const [sx, sy] = worldToScreen(wx, wy);
          if (colorMode === 'single') {
            ctx.fillStyle = `rgba(${sr},${sg},${sb},${opacity})`;
          } else if (colorMode === 'random') {
            ctx.fillStyle = `hsla(${Math.random()*360}, 80%, 60%, ${opacity})`;
          } else {
            ctx.fillStyle = vertexColor(vi, opacity);
          }
          ctx.fillRect(sx - dotSize / 2, sy - dotSize / 2, dotSize, dotSize);
        }
      }

      state.pointsDrawn = batchEnd;

      const pct = (state.pointsDrawn / total) * 100;
      progressFill.style.width = pct + '%';
      progressCount.textContent = `${formatNumber(state.pointsDrawn)} / ${formatNumber(total)}`;
      const elapsed = (performance.now() - state.startTime) / 1000;
      progressRate.textContent = `${formatNumber(Math.round(state.pointsDrawn / elapsed))} pts/s`;

      if (state.pointsDrawn >= total) {
        if (useImageData) {
          ctx.putImageData(imageData, 0, 0);
          drawVertices(verts);
        }
        finishRun();
        return;
      }

      if (useImageData && state.pointsDrawn % (batchSize * 5) < batchSize) {
        ctx.putImageData(imageData, 0, 0);
        drawVertices(verts);
      }

      state.animFrameId = requestAnimationFrame(renderBatch);
    }

    state.animFrameId = requestAnimationFrame(renderBatch);
  }

  function stopRun() {
    state.running = false;
    if (state.animFrameId) cancelAnimationFrame(state.animFrameId);
    runBtn.textContent = 'Run';
    runBtn.className = 'btn btn-run';
    updateInfoOverlay();
  }

  function finishRun() {
    state.running = false;
    runBtn.textContent = 'Run';
    runBtn.className = 'btn btn-run';
    const elapsed = ((performance.now() - state.startTime) / 1000).toFixed(1);
    progressRate.textContent = `Done in ${elapsed}s`;
    updateInfoOverlay();
  }

  function clearCanvas() {
    stopRun();
    clearPointBuffer();
    state.viewCenterX = 0.5;
    state.viewCenterY = 0.5;
    state.viewZoom = 1.0;
    resizeCanvas();
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvasSize, canvasSize);
    state.pointsDrawn = 0;
    progressContainer.style.display = 'none';
    progressFill.style.width = '0%';
    infoOverlay.textContent = '';
    drawVertices(getVertices(state.vertices));
    updateZoomDisplay();
  }

  function saveAs() {
    const link = document.createElement('a');
    const zoomStr = state.viewZoom > 1.01 ? `-${state.viewZoom.toFixed(1)}x` : '';
    const fname = `fractal-N${state.vertices}-F${state.fractalF.toFixed(4)}-${formatNumber(state.pointsStored)}pts${zoomStr}.png`;
    link.download = fname;
    link.href = canvas.toDataURL('image/png');
    link.click();
  }

  // ============================================================
  //  ZOOM / PAN
  // ============================================================
  function updateZoomDisplay() {
    zoomLevelEl.textContent = state.viewZoom >= 10
      ? `${Math.round(state.viewZoom)}x`
      : `${state.viewZoom.toFixed(1)}x`;
  }

  function zoomAt(factor, screenX, screenY) {
    // Zoom centered on a screen point
    const [wx, wy] = screenToWorld(screenX, screenY);
    state.viewZoom *= factor;
    state.viewZoom = Math.max(0.5, Math.min(state.viewZoom, 10000));
    // Adjust center so the world point stays under the cursor
    const newWx = (screenX - canvasSize / 2) / (state.viewZoom * canvasSize) + state.viewCenterX;
    const newWy = (screenY - canvasSize / 2) / (state.viewZoom * canvasSize) + state.viewCenterY;
    state.viewCenterX += wx - newWx;
    state.viewCenterY += wy - newWy;
    renderFromBuffer();
  }

  function zoomIn() { zoomAt(1.5, canvasSize / 2, canvasSize / 2); }
  function zoomOut() { zoomAt(1 / 1.5, canvasSize / 2, canvasSize / 2); }

  function resetZoom() {
    state.viewCenterX = 0.5;
    state.viewCenterY = 0.5;
    state.viewZoom = 1.0;
    renderFromBuffer();
  }

  // ============================================================
  //  MOUSE INTERACTIONS
  // ============================================================
  let isDragging = false;
  let isSelecting = false;
  let dragStartX = 0, dragStartY = 0;
  let dragStartCX = 0, dragStartCY = 0;
  let selStartX = 0, selStartY = 0;

  function getCanvasPos(e) {
    const rect = canvas.getBoundingClientRect();
    return [e.clientX - rect.left, e.clientY - rect.top];
  }

  canvas.addEventListener('mousedown', (e) => {
    if (state.running) return;
    if (state.pointsStored === 0) return;
    e.preventDefault();
    const [mx, my] = getCanvasPos(e);

    if (e.shiftKey) {
      // Selection zoom
      isSelecting = true;
      selStartX = mx;
      selStartY = my;
      selectionRect.style.display = 'block';
      selectionRect.style.left = mx + canvas.offsetLeft + 'px';
      selectionRect.style.top = my + canvas.offsetTop + 'px';
      selectionRect.style.width = '0px';
      selectionRect.style.height = '0px';
      canvasArea.classList.add('select-mode');
      canvasArea.classList.remove('pan-mode');
    } else {
      // Pan
      isDragging = true;
      dragStartX = mx;
      dragStartY = my;
      dragStartCX = state.viewCenterX;
      dragStartCY = state.viewCenterY;
      canvasArea.classList.add('panning');
    }
  });

  window.addEventListener('mousemove', (e) => {
    if (isDragging) {
      const [mx, my] = getCanvasPos(e);
      const dx = (mx - dragStartX) / (state.viewZoom * canvasSize);
      const dy = (my - dragStartY) / (state.viewZoom * canvasSize);
      state.viewCenterX = dragStartCX - dx;
      state.viewCenterY = dragStartCY - dy;
      renderFromBuffer();
    } else if (isSelecting) {
      const [mx, my] = getCanvasPos(e);
      const x = Math.min(selStartX, mx);
      const y = Math.min(selStartY, my);
      const w = Math.abs(mx - selStartX);
      const h = Math.abs(my - selStartY);
      selectionRect.style.left = (x + canvas.offsetLeft) + 'px';
      selectionRect.style.top = (y + canvas.offsetTop) + 'px';
      selectionRect.style.width = w + 'px';
      selectionRect.style.height = h + 'px';
    }
  });

  window.addEventListener('mouseup', (e) => {
    if (isDragging) {
      isDragging = false;
      canvasArea.classList.remove('panning');
    } else if (isSelecting) {
      isSelecting = false;
      selectionRect.style.display = 'none';
      canvasArea.classList.remove('select-mode');
      canvasArea.classList.add('pan-mode');

      const [mx, my] = getCanvasPos(e);
      const x0 = Math.min(selStartX, mx);
      const y0 = Math.min(selStartY, my);
      const w = Math.abs(mx - selStartX);
      const h = Math.abs(my - selStartY);

      if (w > 5 && h > 5) {
        // Zoom to selection
        const [wx0, wy0] = screenToWorld(x0, y0);
        const [wx1, wy1] = screenToWorld(x0 + w, y0 + h);
        state.viewCenterX = (wx0 + wx1) / 2;
        state.viewCenterY = (wy0 + wy1) / 2;
        const worldW = Math.abs(wx1 - wx0);
        const worldH = Math.abs(wy1 - wy0);
        state.viewZoom = 1 / Math.max(worldW, worldH);
        state.viewZoom = Math.max(0.5, Math.min(state.viewZoom, 10000));
        renderFromBuffer();
      }
    }
  });

  canvas.addEventListener('wheel', (e) => {
    if (state.running) return;
    if (state.pointsStored === 0) return;
    e.preventDefault();
    const [mx, my] = getCanvasPos(e);
    const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
    zoomAt(factor, mx, my);
  }, { passive: false });

  canvas.addEventListener('dblclick', (e) => {
    if (state.running) return;
    if (state.pointsStored === 0) return;
    e.preventDefault();
    const [mx, my] = getCanvasPos(e);
    zoomAt(2, mx, my);
  });

  // Shift key cursor toggle
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Shift' && !isDragging && !isSelecting) {
      canvasArea.classList.add('select-mode');
      canvasArea.classList.remove('pan-mode');
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.key === 'Shift' && !isSelecting) {
      canvasArea.classList.remove('select-mode');
      canvasArea.classList.add('pan-mode');
    }
  });

  // ============================================================
  //  CONTROL HANDLERS
  // ============================================================
  verticesSlider.addEventListener('input', () => {
    state.vertices = parseInt(verticesSlider.value);
    document.getElementById('verticesValue').textContent = state.vertices;
    setOptimalF();
    updatePrompt();
    updatePreview();
  });

  pointsSlider.addEventListener('input', () => {
    state.totalPoints = sliderToPoints(parseInt(pointsSlider.value));
    document.getElementById('pointsValue').textContent = formatNumber(state.totalPoints);
    updatePrompt();
  });

  dotSizeSlider.addEventListener('input', () => {
    state.dotSize = parseFloat(dotSizeSlider.value);
    document.getElementById('dotSizeValue').textContent = state.dotSize + ' px';
    updatePrompt();
  });

  opacitySlider.addEventListener('input', () => {
    state.opacity = parseInt(opacitySlider.value) / 100;
    document.getElementById('opacityValue').textContent = parseInt(opacitySlider.value) + '%';
    updatePrompt();
  });

  customFInput.addEventListener('input', () => {
    let val = parseFloat(customFInput.value);
    if (!isNaN(val) && val > 0 && val < 1) {
      state.fractalF = val;
      document.getElementById('fractalValue').textContent = val.toFixed(4);
      document.querySelectorAll('.control-group .preset-row .preset-btn').forEach(b => b.classList.remove('active'));
      updatePrompt();
    }
  });

  dotColorInput.addEventListener('input', () => {
    state.singleColor = dotColorInput.value;
    document.getElementById('colorHex').textContent = dotColorInput.value;
    updatePrompt();
  });

  function setF(val) {
    state.fractalF = val;
    customFInput.value = val.toFixed(4);
    document.getElementById('fractalValue').textContent = val.toFixed(4);

    const optBtn = document.getElementById('optimalBtn');
    const presetBtns = document.querySelectorAll('.control-group .preset-row .preset-btn:not(#optimalBtn)');
    const values = [1/2, 1/3, 2/3, 3/8];
    const optimalF = calcOptimalF(state.vertices);
    const isOptimal = Math.abs(optimalF - val) < 0.0001;
    optBtn.classList.toggle('active', isOptimal);
    if (isOptimal) {
      optBtn.style.background = '';
      optBtn.style.color = '';
      optBtn.style.borderColor = '';
      optBtn.style.fontWeight = '';
    } else {
      optBtn.style.background = 'var(--surface2)';
      optBtn.style.color = 'var(--text)';
      optBtn.style.borderColor = 'var(--border)';
      optBtn.style.fontWeight = '';
    }
    presetBtns.forEach((b, i) => {
      b.classList.toggle('active', Math.abs(values[i] - val) < 0.0001);
    });
    updatePrompt();
  }

  function setColorMode(mode) {
    state.colorMode = mode;
    document.getElementById('singleColorBtn').classList.toggle('active', mode === 'single');
    document.getElementById('randomColorBtn').classList.toggle('active', mode === 'random');
    document.getElementById('vertexColorBtn').classList.toggle('active', mode === 'vertex');
    document.getElementById('colorPickerRow').style.display = mode === 'single' ? 'flex' : 'none';
    updatePrompt();
  }

  function applyPreset(name) {
    const presets = {
      sierpinski: { vertices: 3 },
      pentagon:   { vertices: 5 },
      hexagon:    { vertices: 6 },
      octagon:    { vertices: 8 },
      dodecagon:  { vertices: 12 },
    };
    const p = presets[name];
    if (!p) return;
    state.vertices = p.vertices;
    verticesSlider.value = p.vertices;
    document.getElementById('verticesValue').textContent = p.vertices;
    setOptimalF();
    updatePreview();
    updatePrompt();
  }

  function updatePreview() {
    if (!state.running) {
      resizeCanvas();
      state.viewCenterX = 0.5;
      state.viewCenterY = 0.5;
      state.viewZoom = 1.0;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasSize, canvasSize);
      drawVertices(getVertices(state.vertices));
      state.pointsDrawn = 0;
      clearPointBuffer();
      progressContainer.style.display = 'none';
      updateZoomDisplay();
    }
  }

  function updateInfoOverlay() {
    if (state.pointsStored > 0) {
      let info = `N=${state.vertices} &middot; F=${state.fractalF.toFixed(4)}<br>${formatNumber(state.pointsStored)} points`;
      if (state.viewZoom > 1.01) info += `<br>${state.viewZoom.toFixed(1)}x zoom`;
      infoOverlay.innerHTML = info;
    } else {
      infoOverlay.textContent = '';
    }
  }

  function updatePrompt() {
    const parts = [];
    parts.push(`${state.vertices}-point chaos game fractal`);
    parts.push(`F = ${state.fractalF.toFixed(4)}`);
    parts.push(`${formatNumber(state.totalPoints)} iterations`);
    if (state.colorMode === 'single') parts.push(`color: ${state.singleColor}`);
    else if (state.colorMode === 'random') parts.push(`random colors`);
    else parts.push(`vertex-based coloring`);
    if (state.opacity < 1) parts.push(`opacity: ${Math.round(state.opacity * 100)}%`);
    if (state.dotSize !== 1) parts.push(`dot size: ${state.dotSize}px`);
    document.getElementById('promptOutput').textContent = parts.join(' | ');
  }

  function copyPrompt() {
    const text = document.getElementById('promptOutput').textContent;
    navigator.clipboard.writeText(text).then(() => {
      const btn = document.querySelector('.copy-btn');
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 1500);
    });
  }

  // ============================================================
  //  INIT
  // ============================================================
  function init() {
    resizeCanvas();
    updatePreview();
    updatePrompt();
    setColorMode('single');
  }

  window.addEventListener('resize', () => {
    if (!state.running) {
      resizeCanvas();
      if (state.pointsStored > 0) renderFromBuffer();
      else updatePreview();
    }
  });

  init();
</script>
</body>
</html>
